package HW6;

import java.util.*;
import java.io.*;
import java.awt.*;

public class MapDataDrawer {
  // store map data in grid array
  private int[][] grid; 
  private final int ROWS_COUNT;
  private final int COLS_COUNT;
  
  // Read a 2D array into the grid. Data in file "filename", grid is rows x cols
  public MapDataDrawer(String filename, int rows, int cols) throws Exception {
      ROWS_COUNT = rows;
      COLS_COUNT = cols;
      grid = new int[ROWS_COUNT][COLS_COUNT];

      // Instantiate a Scanner to read from file here.
      Scanner dataPull = new Scanner(new File(filename));

      // Read from file inputting values into grid array
      while(dataPull.hasNextInt()) {
          for (int i = 0; i < rows; i++) {
              for (int j = 0; j < cols; j++) {
                  grid[i][j] = dataPull.nextInt();
              }
          }
      }
  }
  
  /**
   * @return the min value in the entire grid
   */
  public int findMin() {
      int minVal = 0;

      // Nested for loop checking values through each row
      for(int i = 0; i < ROWS_COUNT; i++) {
          for (int j = 0; j < COLS_COUNT; j++) {
              if (minVal < grid[i][j])
                  minVal = grid[i][j];
          }
      }
      return minVal; // Storage variable for lowest value returned
  }
  
  /**
   * @return the max value in the entire grid
   */
  public int findMax() {
      int maxVal = 0;

      // For loop checking values row by row for max
      for(int i = 0; i < ROWS_COUNT; i++) {
          for (int j = 0; j < COLS_COUNT; j++) {
              if (maxVal < grid[i][j])
                  maxVal = grid[i][j];
          }
      }
      return maxVal;  // Returns the greatest value within the grid stored in maxVal
  }
  
  /**
   * @param col the column of the grid to check
   * @return the index of the row with the lowest value in the given col for the grid
   */
  public  int indexOfMinRow(int col){
      int indexOfRow = grid[0][col];  // Starting value within chosen column
      int minOfCol = 0;

      // For loop checking row by row within chosen column
      for(int i = 0; i < ROWS_COUNT; i++) {
          if(grid[i][col] < minOfCol) {
              minOfCol = grid[i][col];
              indexOfRow = i;
          }
      }
      return indexOfRow;  // Returning the index only, with no grid values
  }
  
  /**
   * DON'T CHANGE THIS CODE.
   * Draws the grid using the given Graphics object. 
   * Colors should be grayscale values 0-255, scaled based on min/max values in the grid.
   */
  
  public void drawMap(Graphics g){
      
    int minVal = findMin();
    int maxVal = findMax();
    double range = maxVal - minVal;
    
    for(int row=0; row < grid.length; row++){
      for(int col=0; col<grid[0].length; col++){
         int val = (int)(((grid[row][col]-minVal)/range) * 255);
         //g.setColor(new Color(val,255-val,255-val));
         g.setColor(new Color(val,val,val));
         g.fillRect(col,row,1,1);
        }
    }      
  }
  

   /**
   * Find a path from West-to-East starting at given row.
   * Choose a forward step out of 3 possible forward locations, using greedy method described in assignment.
   * @return the total change in elevation traveled from West-to-East.
   */
  public int drawLowestElevPath(Graphics g, int row) {
      int currY = row; // row in the grid from step one

      // draw initial step - column 0, current row (sent in as parameter)
      g.fillRect(0, row, 1, 1);

      // Code to compute next step
      // For loop looking in next column each interval
      for (int j = 1; j < COLS_COUNT; j++) {

          // If the row isn't at the top of the grid
          if (row != 0) {

              // If the row isn't at the bottom of the grid
              if (row != ROWS_COUNT) {
                  int closestComparedVal = 0;

                  //  For loop checking each value box in the next column touching
                  //  the current value box
                  for (int choice = 0; choice < 3; choice++) {


                  }
              }
          }
      }

    // draw next step where x is currently column and currY is row in grid
    int x = 0; // the value of x will be generated by a loop that goes through the
    // columns, but for now, need something to put in "paint" statement
    g.fillRect(x,currY,1,1);
    
    return 0; // computed change in elevation
  }
  
  /**
   * @return the index of the starting row for the lowest-elevation-change path in the entire grid.
   */
  public int indexOfLowestElevPath(Graphics g){
      // finish this method
      return 0; // row of path with lowest elevation
  
  }
  
  
}